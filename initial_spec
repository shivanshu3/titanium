javascript:
if ((5 + 3) > 10)
{
	console.log("yes");
}
else
{
	console.log("no");
}

j.js:
( 5 3 + 10 > ) ( "yes" print ) ( "no" print ) ifelse

javascript:
int i = 0;
while (i < 10)
{
	console.log("hello, world!");
	i++;
}

j.js:
0 =i ( ^i 10 < ) ( "hello, world!" print ^i ++ =i ) while

---------

10 =foo 20 =bar 4 5 6 + + 100 > if { "woah" print } ^foo 10 + ^bar 10 + + 100 * toString " %" concat "the percentage is: " swap concat print

"C:\foo\file.txt" readLines /foo/ /bar/ searchReplace print

newArray `foo1` `foo2` `foo3` push push push dup length toString `there are ` swap concat ` items in the array` concat print

`C:\foo\file.txt` readLines ^trim map /some_random_regex\!{1,5}/i grep ^print map

( dup length =len 0 =i 0 =sum ( ^i ^len < ) ( dup ^i [] ^sum + =sum ) while ^len / ) =avg
`C:\foo\file.txt` readLines ^trim map /^\d+$/ grep ^parseInt map avg print

We could have aliases for commonly used operators like map, grep, print like the following:
m <=> map
g <=> grep
p <=> print
`C:\foo\file.txt` readLines ^trim m /^\d+$/ g ^parseInt m avg p

---------

`-` readLines /foo/ grep 100 =id ( /foo(\d+)/ ^id searchReplace ^id ++ =id ) map ^p map

This is how an end user could use this language:
dir | j /modules=C:\j\modules /debug=true `-` rl /error\\.txt/i g p
OR
dir | j `-` rl /error\\.txt/i g p


dir | grep /error.txt/ | sort | uniq

foo11="error jdfhk"
foo87="sdjhj jfh d"
foo45="nsdbfh dh "

foo100="error jdfhk"
foo101="sdjhj jfh d"
foo102="nsdbfh dh "