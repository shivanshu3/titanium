{
    function makeSymbolOperator(text) {
        return {
            type: 'symbolOperator',
            name: text
        };
    }

    function makeVariableOperator(opType, text){
        return {
            type: 'variableOperator',
            opType: opType,
            name: text
        };
    }
}

start
    = expression

expression
    = terms:( _ term _ )+ {
        var result = terms.map(x => {
            return x[1];
        });
        return {terms:result};
    }

procedure
    = '(' expr:expression ')' {
        return {
            type: 'procedure',
            expression: expr
        }
    }

term
    = literal
    / operator
    / procedure

operator
    = wordOperator
    / variableOperator
    / symbolOperator

wordOperator
    = name:identifier {
        return {
            type: 'wordOperator',
            name: name
        };
    }

symbolOperator
    = '++' { return makeSymbolOperator(text()); }
    / '--' { return makeSymbolOperator(text()); }
    / '+' { return makeSymbolOperator(text()); }
    / '-' { return makeSymbolOperator(text()); }
    / '*' { return makeSymbolOperator(text()); }
    / '/' { return makeSymbolOperator(text()); }

variableOperator
    = '=' name:identifier { return makeVariableOperator('=', name); }
    / '^' name:identifier { return makeVariableOperator('^', name); }

identifier
    = head:[a-zA-Z_] tail:[a-zA-Z_0-9]*
    { return head + tail.join(''); }

literal
    = number
    / boolean
    / string

number
    = digits:[0-9]+ {
        return {
            type: 'literal',
            literalType: 'number',
            value: parseInt(digits.join(''), 10)
        }
    }

boolean
    = 'true' {
        return {
            type: 'literal',
            literalType: 'bool',
            value: true
        };
    }
    / 'false' {
        return {
            type: 'literal',
            literalType: 'bool',
            value: false
        };
    }

string
    = quotation_mark chars:char* quotation_mark {
        return {
            type: 'literal',
            literalType: 'string',
            value: chars.join("")
        };
    }

char
    = unescaped
    / escape
    sequence:(
        '"'
        / '\\'
        / '/'
        / 'b' { return '\b'; }
        / 'f' { return '\f'; }
        / 'n' { return '\n'; }
        / 'r' { return '\r'; }
        / 't' { return '\t'; }
        / 'u' digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
            return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape
    = '\\'

quotation_mark
    = '`'

unescaped
    = [^\0-\x1F\x60\x5C]

// ----- Core ABNF Rules -----
// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
DIGIT  = [0-9]
HEXDIG = [0-9a-f]i

_ "whitespace"
    = [ \t\n\r]* { return null; }